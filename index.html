<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>SpriteForge</title>

  <!-- React CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body { margin:0; background:#0a0a12; }
  </style>
</head>

<body>
  <div id="root"></div>

<script type="text/babel">

const { useState, useRef, useCallback, useEffect } = React;

function SpriteForge() {

  const [image, setImage] = useState(null);
  const [imageSrc, setImageSrc] = useState(null);
  const [frames, setFrames] = useState([]);
  const [currentFrame, setCurrentFrame] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [fps, setFps] = useState(8);

  const animRef = useRef(null);
  const lastTimeRef = useRef(0);

  // --- Image Upload ---
  const handleImageUpload = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      const img = new Image();
      img.onload = () => {
        setImage(img);
        setImageSrc(ev.target.result);
        generateSimpleFrames(img);
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  };

  // --- Simple grid split (4 frames horizontal) ---
  const generateSimpleFrames = (img) => {
    const cols = 4;
    const frameWidth = img.width / cols;
    const frameHeight = img.height;

    const newFrames = [];

    for (let i = 0; i < cols; i++) {
      const canvas = document.createElement("canvas");
      canvas.width = frameWidth;
      canvas.height = frameHeight;
      const ctx = canvas.getContext("2d");

      ctx.drawImage(
        img,
        i * frameWidth, 0,
        frameWidth, frameHeight,
        0, 0,
        frameWidth, frameHeight
      );

      newFrames.push(canvas.toDataURL());
    }

    setFrames(newFrames);
  };

  // --- Animation ---
  useEffect(() => {
    if (!isPlaying || frames.length === 0) return;

    const interval = 1000 / fps;
    let frameIndex = 0;

    const animate = (ts) => {
      if (ts - lastTimeRef.current >= interval) {
        lastTimeRef.current = ts;
        setCurrentFrame(frameIndex);
        frameIndex = (frameIndex + 1) % frames.length;
      }
      animRef.current = requestAnimationFrame(animate);
    };

    animRef.current = requestAnimationFrame(animate);

    return () => cancelAnimationFrame(animRef.current);
  }, [isPlaying, fps, frames]);

  return (
    <div style={{
      minHeight: "100vh",
      color: "#e0e0e0",
      fontFamily: "monospace",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      padding: "20px"
    }}>

      <h1 style={{
        background: "linear-gradient(135deg,#ff6b9d,#c44dff,#6bbaff)",
        WebkitBackgroundClip: "text",
        WebkitTextFillColor: "transparent"
      }}>
        ⚔ SPRITE FORGE
      </h1>

      <input type="file" accept="image/*" onChange={handleImageUpload} />

      {frames.length > 0 && (
        <>
          <div style={{
            marginTop: "20px",
            background: "#1a1a2e",
            padding: "20px",
            borderRadius: "12px"
          }}>
            <img
              src={frames[currentFrame]}
              style={{
                imageRendering: "pixelated",
                width: "200px"
              }}
            />
          </div>

          <div style={{ marginTop: "15px" }}>
            <button onClick={() => setIsPlaying(!isPlaying)}>
              {isPlaying ? "停止" : "再生"}
            </button>
          </div>
        </>
      )}
    </div>
  );
}

// --- Mount ---
ReactDOM.createRoot(document.getElementById("root"))
  .render(<SpriteForge />);

</script>
</body>
</html>